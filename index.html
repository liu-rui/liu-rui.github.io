<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>liu-rui的blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="liu-rui的blog">
<meta property="og:url" content="https://liu-rui.github.io/index.html">
<meta property="og:site_name" content="liu-rui的blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liu-rui的blog">
  
    <link rel="alternate" href="/atom.xml" title="liu-rui的blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">liu-rui的blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://liu-rui.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-consul" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/06/consul/" class="article-date">
  <time datetime="2019-09-06T03:04:39.000Z" itemprop="datePublished">2019-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/06/consul/">consul</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>部署</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://releases.hashicorp.com/consul/1.6.0/consul_1.6.0_linux_amd64.zip</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://liu-rui.github.io/2019/09/06/consul/" data-id="ck0evarq20000twnnw4p0ya56" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-微服务" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/06/微服务/" class="article-date">
  <time datetime="2019-09-06T02:05:24.000Z" itemprop="datePublished">2019-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/06/微服务/">微服务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>服务发现：consul    ok</p>
<p>网关：kong     </p>
<p>服务调用: spring cloud feign  ok</p>
<p>熔断： </p>
<p>配置中心： apollo   ok</p>
<p>链路跟踪:</p>
<p>指标监控：cat</p>
<p>分布式任务系统：</p>
<p>日志中心：</p>
<p>编排：k8s</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liu-rui.github.io/2019/09/06/微服务/" data-id="ck0evarqq000atwnnkokoy7rj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-idea使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/29/idea使用/" class="article-date">
  <time datetime="2019-07-29T01:03:04.000Z" itemprop="datePublished">2019-07-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/29/idea使用/">idea使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.插件</p>
<p>.ignore</p>
<p>Alibaba Java Coding Guidelines </p>
<p>CamelCase</p>
<p>Key Promoter X</p>
<p>lombok</p>
<p>maven helper</p>
<p>statistic</p>
<p>Rainbow Brackets + Material Theme UI(Oceanic theme) + Nyan Progress Bar + Menlo(Font)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liu-rui.github.io/2019/07/29/idea使用/" data-id="ck0evarq90003twnnsjnr9toq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-flutter环境搭建" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/17/flutter环境搭建/" class="article-date">
  <time datetime="2019-07-17T01:38:44.000Z" itemprop="datePublished">2019-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/17/flutter环境搭建/">flutter环境搭建</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>dart sdk下载</p>
<p>源码地址：<a href="https://github.com/dart-lang/sdk" target="_blank" rel="noopener">https://github.com/dart-lang/sdk</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:dart-lang/sdk.git</span><br></pre></td></tr></table></figure>

<p>配置环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DART_HOME</span><br><span class="line">PATH</span><br></pre></td></tr></table></figure>

<p>flutter sdk 下载</p>
<p>参考官方文档 <a href="https://flutter.dev/community/china" target="_blank" rel="noopener">https://flutter.dev/community/china</a></p>
<p>下载压缩包</p>
<p>配置环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class="line">export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br><span class="line">Path //将flutter/bin添加到Path中</span><br></pre></td></tr></table></figure>

<p>android studio 下载</p>
<p>下载地址：<a href="https://developer.android.google.cn/studio/" target="_blank" rel="noopener">https://developer.android.google.cn/studio/</a></p>
<p>按照插件：dart,flutter</p>
<p>测试下环境</p>
<p>flutter doctor</p>
<p>第一个程序</p>
<p>打开android studio</p>
<p>新建new project -&gt; flutter</p>
<p>手机接入，开启usb调试模式</p>
<p>点击运行</p>
<p>可能会卡在init gradle阶段</p>
<p>打开android-&gt;gradle.bat文件,修改为以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set CLASSPATH=D:\software\gradle-5.4.1\lib\gradle-launcher-5.4.1.jar</span><br><span class="line"></span><br><span class="line">&quot;%JAVA_EXE%&quot; %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% &quot;-Dorg.gradle.appname=%APP_BASE_NAME%&quot; -classpath &quot;%CLASSPATH%&quot; org.gradle.launcher.GradleMain %CMD_LINE_ARGS%</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://liu-rui.github.io/2019/07/17/flutter环境搭建/" data-id="ck0evarq80002twnndgxefxf3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/flutter/">flutter</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-spring源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/01/spring源码分析/" class="article-date">
  <time datetime="2019-07-01T01:32:32.000Z" itemprop="datePublished">2019-07-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/01/spring源码分析/">spring源码分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本课程基于spring,开发工具idea 2019.1</p>
<table>
<thead>
<tr>
<th>spring源码版本</th>
<th>5.1.x</th>
</tr>
</thead>
<tbody><tr>
<td>gradle</td>
<td>5.4.1</td>
</tr>
<tr>
<td>IDEA</td>
<td>2019.1</td>
</tr>
<tr>
<td>源码地址</td>
<td><a href="https://github.com/spring-projects/spring-framework" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework</a></td>
</tr>
<tr>
<td>官方文档</td>
<td><a href="https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/</a></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="1-本地编译源码"><a href="#1-本地编译源码" class="headerlink" title="1.  本地编译源码"></a>1.  本地编译源码</h1><h2 id="1-安装gradle"><a href="#1-安装gradle" class="headerlink" title="1. 安装gradle"></a>1. 安装gradle</h2><h3 id="1-下载gradle"><a href="#1-下载gradle" class="headerlink" title="1. 下载gradle"></a>1. 下载gradle</h3><p>下载地址为 <a href="https://gradle.org/releases/" target="_blank" rel="noopener">https://gradle.org/releases/</a>   ，对应的版本为5.4.1</p>
<h3 id="2-解压"><a href="#2-解压" class="headerlink" title="2. 解压"></a>2. 解压</h3><h3 id="3-配置环境变量"><a href="#3-配置环境变量" class="headerlink" title="3. 配置环境变量"></a>3. 配置环境变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GRADLE_HOME</span><br><span class="line">PATH</span><br></pre></td></tr></table></figure>

<h3 id="4-测试下gradle是否安装成功"><a href="#4-测试下gradle是否安装成功" class="headerlink" title="4. 测试下gradle是否安装成功"></a>4. 测试下gradle是否安装成功</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle -v</span><br></pre></td></tr></table></figure>

<h2 id="2-本地编译spring源码"><a href="#2-本地编译spring源码" class="headerlink" title="2. 本地编译spring源码"></a>2. 本地编译spring源码</h2><h3 id="1-fork一份spring源码到自己的仓库"><a href="#1-fork一份spring源码到自己的仓库" class="headerlink" title="1. fork一份spring源码到自己的仓库"></a>1. fork一份spring源码到自己的仓库</h3><h3 id="2-git-clone-到本地"><a href="#2-git-clone-到本地" class="headerlink" title="2. git clone 到本地"></a>2. git clone 到本地</h3><h3 id="3-修改spring源码，解决编译过程中报错的问题"><a href="#3-修改spring源码，解决编译过程中报错的问题" class="headerlink" title="3. 修改spring源码，解决编译过程中报错的问题"></a>3. 修改spring源码，解决编译过程中报错的问题</h3><h4 id="1-修改gradle-docs-gradle文件schemaZip方法"><a href="#1-修改gradle-docs-gradle文件schemaZip方法" class="headerlink" title="1. 修改gradle\docs.gradle文件schemaZip方法"></a>1. 修改gradle\docs.gradle文件schemaZip方法</h4><ul>
<li>line 151，META-INF/spring.schemas改为META-INF\spring.schemas</li>
<li>line 158, schemas.get(key)后面增加以下方法，.replaceAll(‘\/‘,’\\‘)<h3 id="4-编译代码"><a href="#4-编译代码" class="headerlink" title="4. 编译代码"></a>4. 编译代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle build</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>等待编译完成，需要很长的时间</p>
<h3 id="5-测试下是否编译通过"><a href="#5-测试下是否编译通过" class="headerlink" title="5. 测试下是否编译通过"></a>5. 测试下是否编译通过</h3><h4 id="1-添加模块Demo1，选择Gradle项目-gt-java"><a href="#1-添加模块Demo1，选择Gradle项目-gt-java" class="headerlink" title="1. 添加模块Demo1，选择Gradle项目-&gt; java"></a>1. 添加模块Demo1，选择Gradle项目-&gt; java</h4><h4 id="2-修改项目的build-gradle-增加对spring-context模块的依赖"><a href="#2-修改项目的build-gradle-增加对spring-context模块的依赖" class="headerlink" title="2.  修改项目的build.gradle,增加对spring-context模块的依赖"></a>2.  修改项目的build.gradle,增加对spring-context模块的依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile(project(&quot;:spring-context&quot;))</span><br></pre></td></tr></table></figure>

<h4 id="3-修改spring-context模块的spring-context-gradle文件"><a href="#3-修改spring-context模块的spring-context-gradle文件" class="headerlink" title="3.  修改spring-context模块的spring-context.gradle文件"></a>3.  修改spring-context模块的spring-context.gradle文件</h4><p>由于默认配置文件中spring-instrument的引用配置为了optional，造成报错，修改为compile</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile(project(&quot;:spring-instrument&quot;))</span><br></pre></td></tr></table></figure>

<h4 id="4-添加App-Java文件，代码如下"><a href="#4-添加App-Java文件，代码如下" class="headerlink" title="4.  添加App.Java文件，代码如下"></a>4.  添加App.Java文件，代码如下</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"a"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(App.class);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (String beanDefinitionName : applicationContext.getBeanDefinitionNames()) &#123;</span><br><span class="line">			System.out.println(beanDefinitionName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-添加service-CustomerService-java文件-代码如下"><a href="#5-添加service-CustomerService-java文件-代码如下" class="headerlink" title="5. 添加service/CustomerService.java文件,代码如下:"></a>5. 添加service/CustomerService.java文件,代码如下:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-运行main函数-输出结果如下"><a href="#6-运行main函数-输出结果如下" class="headerlink" title="6.  运行main函数,输出结果如下"></a>6.  运行main函数,输出结果如下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">app</span><br><span class="line">customerService</span><br></pre></td></tr></table></figure>

<h1 id="2-AnnotationConfigApplicationContext执行流程"><a href="#2-AnnotationConfigApplicationContext执行流程" class="headerlink" title="2.  AnnotationConfigApplicationContext执行流程"></a>2.  AnnotationConfigApplicationContext执行流程</h1><p>使用spring initialzr创建项目,入口类代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo58;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.example"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo58Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext   applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(Demo58Application.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String beanDefinitionName : applicationContext.getBeanDefinitionNames()) &#123;</span><br><span class="line">            System.out.println(beanDefinitionName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调试我们看下代码整个执行过程：</p>
<p>总体只执行了三个方法：</p>
<ol>
<li><p>this()，调用了无参数构造函数</p>
</li>
<li><p>register(annotatedClasses);调用注册方法</p>
</li>
<li><p>refresh()；调用了刷新方法，注意此方法来源于【AbstractApplicationContext】</p>
</li>
</ol>
<p>接下来我们对这三个方法进行分析</p>
<h2 id="1-this-无参数构造函数"><a href="#1-this-无参数构造函数" class="headerlink" title="1. this();无参数构造函数"></a>1. this();无参数构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.classLoader = ClassUtils.getDefaultClassLoader();</span><br><span class="line"><span class="keyword">this</span>.resourcePatternResolver = getResourcePatternResolver();</span><br><span class="line"><span class="keyword">this</span>.beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory(); </span><br><span class="line"><span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<h3 id="1-初始化classLoader，链式赋值"><a href="#1-初始化classLoader，链式赋值" class="headerlink" title="1. 初始化classLoader，链式赋值"></a>1. 初始化classLoader，链式赋值</h3><ol>
<li>使用当前线程的上下文类加载器【Thread.currentThread().getContextClassLoader()】;</li>
<li>使用ClassUtils类的类加载器【ClassUtils.class.getClassLoader()】</li>
<li>使用系统类加载器【ClassLoader.getSystemClassLoader()】</li>
</ol>
<h3 id="2-初始化resourcePatternResolver-此赋值来源于AbstractApplicationContext"><a href="#2-初始化resourcePatternResolver-此赋值来源于AbstractApplicationContext" class="headerlink" title="2. 初始化resourcePatternResolver,此赋值来源于AbstractApplicationContext"></a>2. 初始化resourcePatternResolver,此赋值来源于<strong>AbstractApplicationContext</strong></h3><p>使用了PathMatchingResourcePatternResolver,即Ant-style路径模式</p>
<h3 id="3-初始化beanFactory，此赋值来源于GenericApplicationContext"><a href="#3-初始化beanFactory，此赋值来源于GenericApplicationContext" class="headerlink" title="3. 初始化beanFactory，此赋值来源于GenericApplicationContext"></a>3. 初始化beanFactory，此赋值来源于<strong>GenericApplicationContext</strong></h3><p>默认使用了DefaultListableBeanFactory类型</p>
<h3 id="4-初始化reader-使用注解方式的bean定义读取器"><a href="#4-初始化reader-使用注解方式的bean定义读取器" class="headerlink" title="4. 初始化reader,使用注解方式的bean定义读取器"></a>4. 初始化reader,使用注解方式的bean定义读取器</h3><p>new AnnotatedBeanDefinitionReader(this)，内部代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.registry = registry;</span><br><span class="line"><span class="keyword">this</span>.conditionEvaluator = <span class="keyword">new</span> ConditionEvaluator(registry, environment, <span class="keyword">null</span>);</span><br><span class="line">AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br></pre></td></tr></table></figure>

<p>默认会增加5个内置的PostProcessor:</p>
<table>
<thead>
<tr>
<th>类</th>
<th>类别</th>
<th>接口</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>ConfigurationClassPostProcessor</td>
<td>BeanFactoryPostProcessor</td>
<td></td>
<td>通过扫描加载bean定义</td>
</tr>
<tr>
<td>AutowiredAnnotationBeanPostProcessor</td>
<td>BeanPostProcessor</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CommonAnnotationBeanPostProcessor</td>
<td>BeanPostProcessor</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PersistenceAnnotationBeanPostProcessor</td>
<td>BeanPostProcessor</td>
<td></td>
<td></td>
</tr>
<tr>
<td>DefaultEventListenerFactory</td>
<td>EventListenerFactory</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>该方法执行步骤如下：</p>
<h4 id="1-将当前的容器对象赋值给registry"><a href="#1-将当前的容器对象赋值给registry" class="headerlink" title="1. 将当前的容器对象赋值给registry"></a>1. 将当前的容器对象赋值给registry</h4><h4 id="2-新建conditionEvaluator（条件评估），作用是为对注解进行评估"><a href="#2-新建conditionEvaluator（条件评估），作用是为对注解进行评估" class="headerlink" title="2. 新建conditionEvaluator（条件评估），作用是为对注解进行评估"></a>2. 新建conditionEvaluator（条件评估），作用是为对注解进行评估</h4><h4 id="3-注册预定义的注解配置处理器"><a href="#3-注册预定义的注解配置处理器" class="headerlink" title="3. 注册预定义的注解配置处理器"></a>3. 注册预定义的注解配置处理器</h4><h5 id="1-获取BeanFactory"><a href="#1-获取BeanFactory" class="headerlink" title="1. 获取BeanFactory"></a>1. 获取BeanFactory</h5><h5 id="2-如果BeanFactory有值："><a href="#2-如果BeanFactory有值：" class="headerlink" title="2. 如果BeanFactory有值："></a>2. 如果BeanFactory有值：</h5><h6 id="1-如果beanFactory-getDependencyComparator不是AnnotationAwareOrderComparator的话，调用beanFactory-setDependencyComparator-AnnotationAwareOrderComparator-INSTANCE"><a href="#1-如果beanFactory-getDependencyComparator不是AnnotationAwareOrderComparator的话，调用beanFactory-setDependencyComparator-AnnotationAwareOrderComparator-INSTANCE" class="headerlink" title="1. 如果beanFactory.getDependencyComparator不是AnnotationAwareOrderComparator的话，调用beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE)"></a>1. 如果beanFactory.getDependencyComparator不是AnnotationAwareOrderComparator的话，调用beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE)</h6><h6 id="2-如果beanFactory-getAutowireCandidateResolver不是ContextAnnotationAutowireCandidateResolver，调用beanFactory-setAutowireCandidateResolver-new-ContextAnnotationAutowireCandidateResolver"><a href="#2-如果beanFactory-getAutowireCandidateResolver不是ContextAnnotationAutowireCandidateResolver，调用beanFactory-setAutowireCandidateResolver-new-ContextAnnotationAutowireCandidateResolver" class="headerlink" title="2. 如果beanFactory.getAutowireCandidateResolver不是ContextAnnotationAutowireCandidateResolver，调用beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver())"></a>2. 如果beanFactory.getAutowireCandidateResolver不是ContextAnnotationAutowireCandidateResolver，调用beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver())</h6><h5 id="3-如果registry没有名为org-springframework-context-annotation-internalConfigurationAnnotationProcessor的bean定义，registry添加bean定义，类型为ConfigurationClassPostProcessor"><a href="#3-如果registry没有名为org-springframework-context-annotation-internalConfigurationAnnotationProcessor的bean定义，registry添加bean定义，类型为ConfigurationClassPostProcessor" class="headerlink" title="3. 如果registry没有名为org.springframework.context.annotation.internalConfigurationAnnotationProcessor的bean定义，registry添加bean定义，类型为ConfigurationClassPostProcessor"></a>3. 如果registry没有名为org.springframework.context.annotation.internalConfigurationAnnotationProcessor的bean定义，registry添加bean定义，类型为ConfigurationClassPostProcessor</h5><h5 id="4-如果registry没有名为org-springframework-context-annotation-internalAutowiredAnnotationProcessor的bean定义，registry添加bean定义，类型为AutowiredAnnotationBeanPostProcessor"><a href="#4-如果registry没有名为org-springframework-context-annotation-internalAutowiredAnnotationProcessor的bean定义，registry添加bean定义，类型为AutowiredAnnotationBeanPostProcessor" class="headerlink" title="4. 如果registry没有名为org.springframework.context.annotation.internalAutowiredAnnotationProcessor的bean定义，registry添加bean定义，类型为AutowiredAnnotationBeanPostProcessor"></a>4. 如果registry没有名为org.springframework.context.annotation.internalAutowiredAnnotationProcessor的bean定义，registry添加bean定义，类型为AutowiredAnnotationBeanPostProcessor</h5><h5 id="5-如果具备JSR250功能并且registry没有名为org-springframework-context-annotation-internalCommonAnnotationProcessor的bean定义，registry添加bean定义，类型为CommonAnnotationBeanPostProcessor"><a href="#5-如果具备JSR250功能并且registry没有名为org-springframework-context-annotation-internalCommonAnnotationProcessor的bean定义，registry添加bean定义，类型为CommonAnnotationBeanPostProcessor" class="headerlink" title="5. 如果具备JSR250功能并且registry没有名为org.springframework.context.annotation.internalCommonAnnotationProcessor的bean定义，registry添加bean定义，类型为CommonAnnotationBeanPostProcessor"></a>5. 如果具备JSR250功能并且registry没有名为org.springframework.context.annotation.internalCommonAnnotationProcessor的bean定义，registry添加bean定义，类型为CommonAnnotationBeanPostProcessor</h5><p> 是否具备具备JSR250功能，是通过判断类javax.annotation.Resource是否存在</p>
<h5 id="6-如果具备JPA功能并且registry没有名为org-springframework-context-annotation-internalPersistenceAnnotationProcessor的bean定义，registry添加bean定义，类型为org-springframework-orm-jpa-support-PersistenceAnnotationBeanPostProcessor"><a href="#6-如果具备JPA功能并且registry没有名为org-springframework-context-annotation-internalPersistenceAnnotationProcessor的bean定义，registry添加bean定义，类型为org-springframework-orm-jpa-support-PersistenceAnnotationBeanPostProcessor" class="headerlink" title="6.  如果具备JPA功能并且registry没有名为org.springframework.context.annotation.internalPersistenceAnnotationProcessor的bean定义，registry添加bean定义，类型为org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"></a>6.  如果具备JPA功能并且registry没有名为org.springframework.context.annotation.internalPersistenceAnnotationProcessor的bean定义，registry添加bean定义，类型为org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor</h5><p>是否具备具备JPA功能，是通过判断类javax.persistence.EntityManagerFactory是否存在</p>
<h5 id="7-如果registry没有名为org-springframework-context-event-internalEventListenerProcessor的bean定义，registry添加bean定义，类型为EventListenerMethodProcessor"><a href="#7-如果registry没有名为org-springframework-context-event-internalEventListenerProcessor的bean定义，registry添加bean定义，类型为EventListenerMethodProcessor" class="headerlink" title="7. 如果registry没有名为org.springframework.context.event.internalEventListenerProcessor的bean定义，registry添加bean定义，类型为EventListenerMethodProcessor"></a>7. 如果registry没有名为org.springframework.context.event.internalEventListenerProcessor的bean定义，registry添加bean定义，类型为EventListenerMethodProcessor</h5><h5 id="8-如果registry没有名为org-springframework-context-event-internalEventListenerFactory的bean定义，registry添加bean定义，类型为DefaultEventListenerFactory"><a href="#8-如果registry没有名为org-springframework-context-event-internalEventListenerFactory的bean定义，registry添加bean定义，类型为DefaultEventListenerFactory" class="headerlink" title="8. 如果registry没有名为org.springframework.context.event.internalEventListenerFactory的bean定义，registry添加bean定义，类型为DefaultEventListenerFactory"></a>8. 如果registry没有名为org.springframework.context.event.internalEventListenerFactory的bean定义，registry添加bean定义，类型为DefaultEventListenerFactory</h5><h3 id="5-初始化scanner-使用类路径方式的bean定义扫描器"><a href="#5-初始化scanner-使用类路径方式的bean定义扫描器" class="headerlink" title="5. 初始化scanner,使用类路径方式的bean定义扫描器"></a>5. 初始化scanner,使用类路径方式的bean定义扫描器</h3><h2 id="2-register-annotatedClasses-调用注册方法"><a href="#2-register-annotatedClasses-调用注册方法" class="headerlink" title="2. register(annotatedClasses);调用注册方法"></a>2. register(annotatedClasses);调用注册方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> </span>&#123;</span><br><span class="line">		Assert.notEmpty(annotatedClasses, <span class="string">"At least one annotated class must be specified"</span>);</span><br><span class="line">		<span class="keyword">this</span>.reader.register(annotatedClasses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了reader属性的register方法,代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (Class&lt;?&gt; annotatedClass : annotatedClasses) &#123;</span><br><span class="line">			registerBean(annotatedClass);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用：将annotatedClass对应的bean定义注册到容器中</p>
<p>循环传入的注解的接口，调用registerBean方法；</p>
<p>registerBean执行流程如下：</p>
<h3 id="1-获取annotatedClasses的Bean定义对象"><a href="#1-获取annotatedClasses的Bean定义对象" class="headerlink" title="1. 获取annotatedClasses的Bean定义对象"></a>1. 获取annotatedClasses的Bean定义对象</h3><h3 id="2-调用conditionEvaluator-shouldSkip方法，判断是否应该跳过，由于没有标注conditional注解，不用跳过"><a href="#2-调用conditionEvaluator-shouldSkip方法，判断是否应该跳过，由于没有标注conditional注解，不用跳过" class="headerlink" title="2. 调用conditionEvaluator.shouldSkip方法，判断是否应该跳过，由于没有标注conditional注解，不用跳过"></a>2. 调用conditionEvaluator.shouldSkip方法，判断是否应该跳过，由于没有标注conditional注解，不用跳过</h3><h3 id="3-获取作用范围元数据信息"><a href="#3-获取作用范围元数据信息" class="headerlink" title="3. 获取作用范围元数据信息"></a>3. 获取作用范围元数据信息</h3><h3 id="4-调用AnnotationConfigUtils-processCommonDefinitionAnnotations-abd-，作用是根据类标注的注解信息设置bean定义属性"><a href="#4-调用AnnotationConfigUtils-processCommonDefinitionAnnotations-abd-，作用是根据类标注的注解信息设置bean定义属性" class="headerlink" title="4. 调用AnnotationConfigUtils.processCommonDefinitionAnnotations(abd)，作用是根据类标注的注解信息设置bean定义属性"></a>4. 调用AnnotationConfigUtils.processCommonDefinitionAnnotations(abd)，作用是根据类标注的注解信息设置bean定义属性</h3><p>​    是否标注了lazy注解，标注的话设置setLazyInit</p>
<p>​    是否标注了Primary注解，标注的话设置setPrimary为true</p>
<p>​    是否标注了DependsOn注解，标注的话设置setDependsOn</p>
<p>​    是否标注了Role注解，标注的话设置setRole</p>
<p>​    是否标注了Description注解，标注的话设置setDescription</p>
<h3 id="5-将bean定义添加到容器中，调用BeanDefinitionReaderUtils-registerBeanDefinition-definitionHolder-this-registry"><a href="#5-将bean定义添加到容器中，调用BeanDefinitionReaderUtils-registerBeanDefinition-definitionHolder-this-registry" class="headerlink" title="5. 将bean定义添加到容器中，调用BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry)"></a>5. 将bean定义添加到容器中，调用BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry)</h3><h2 id="3-refresh-；刷新方法"><a href="#3-refresh-；刷新方法" class="headerlink" title="3. refresh()；刷新方法"></a>3. refresh()；刷新方法</h2><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">			prepareRefresh();</span><br><span class="line">			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">			prepareBeanFactory(beanFactory);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				postProcessBeanFactory(beanFactory);</span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">				registerBeanPostProcessors(beanFactory);</span><br><span class="line">				initMessageSource();</span><br><span class="line">				initApplicationEventMulticaster();</span><br><span class="line">				onRefresh();</span><br><span class="line">				registerListeners();</span><br><span class="line">				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">				finishRefresh();</span><br><span class="line">			&#125;<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				destroyBeans();</span><br><span class="line">				cancelRefresh(ex);</span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">				resetCommonCaches();</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-synchronized-this-startupShutdownMonitor-线程同步"><a href="#1-synchronized-this-startupShutdownMonitor-线程同步" class="headerlink" title="1.  synchronized (this.startupShutdownMonitor); 线程同步"></a>1.  synchronized (this.startupShutdownMonitor); 线程同步</h3><h3 id="2-prepareRefresh"><a href="#2-prepareRefresh" class="headerlink" title="2.  prepareRefresh()"></a>2.  prepareRefresh()</h3><p>作用：刷新前准备</p>
<p>执行过程如下：</p>
<h4 id="1-startupDate设置为当前时间"><a href="#1-startupDate设置为当前时间" class="headerlink" title="1. startupDate设置为当前时间"></a>1. startupDate设置为当前时间</h4><h4 id="2-closed为false"><a href="#2-closed为false" class="headerlink" title="2. closed为false"></a>2. closed为false</h4><h4 id="3-active为true"><a href="#3-active为true" class="headerlink" title="3.  active为true"></a>3.  active为true</h4><h4 id="4-initPropertySources-，初始化属性来源"><a href="#4-initPropertySources-，初始化属性来源" class="headerlink" title="4. initPropertySources()，初始化属性来源"></a>4. initPropertySources()，初始化属性来源</h4><h4 id="5-getEnvironment-validateRequiredProperties-，验证必要的属性，如果Environment不存在使用StandardEnvironment实例"><a href="#5-getEnvironment-validateRequiredProperties-，验证必要的属性，如果Environment不存在使用StandardEnvironment实例" class="headerlink" title="5. getEnvironment().validateRequiredProperties()，验证必要的属性，如果Environment不存在使用StandardEnvironment实例"></a>5. getEnvironment().validateRequiredProperties()，验证必要的属性，如果Environment不存在使用StandardEnvironment实例</h4><h4 id="6-判断earlyApplicationListeners是否为null"><a href="#6-判断earlyApplicationListeners是否为null" class="headerlink" title="6. 判断earlyApplicationListeners是否为null"></a>6. 判断earlyApplicationListeners是否为null</h4><h5 id="1-如果为null-说明是容器是首次运行，earlyApplicationListeners值来源于applicationListeners，而此时的applicationListeners数据是通过调用了容器的addApplicationListener-方法添加的。"><a href="#1-如果为null-说明是容器是首次运行，earlyApplicationListeners值来源于applicationListeners，而此时的applicationListeners数据是通过调用了容器的addApplicationListener-方法添加的。" class="headerlink" title="1. 如果为null,说明是容器是首次运行，earlyApplicationListeners值来源于applicationListeners，而此时的applicationListeners数据是通过调用了容器的addApplicationListener()方法添加的。"></a>1. 如果为null,说明是容器是首次运行，earlyApplicationListeners值来源于applicationListeners，而此时的applicationListeners数据是通过调用了容器的addApplicationListener()方法添加的。</h5><h5 id="2-不为null-重置下applicationListeners：清空，将earlyApplicationListeners全部加进来。"><a href="#2-不为null-重置下applicationListeners：清空，将earlyApplicationListeners全部加进来。" class="headerlink" title="2. 不为null,重置下applicationListeners：清空，将earlyApplicationListeners全部加进来。"></a>2. 不为null,重置下applicationListeners：清空，将earlyApplicationListeners全部加进来。</h5><h4 id="7-初始化earlyApplicationEvents为LinkedHashSet"><a href="#7-初始化earlyApplicationEvents为LinkedHashSet" class="headerlink" title="7. 初始化earlyApplicationEvents为LinkedHashSet"></a>7. 初始化earlyApplicationEvents为LinkedHashSet</h4><h3 id="3-ConfigurableListableBeanFactory-beanFactory-obtainFreshBeanFactory"><a href="#3-ConfigurableListableBeanFactory-beanFactory-obtainFreshBeanFactory" class="headerlink" title="3. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();"></a>3. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</h3><p>作用： 刷新下BeanFactory,并且返回</p>
<p>this.beanFactory.setSerializationId(getId());</p>
<p>将beanFactory的SerializationId设置为容器的id</p>
<h3 id="4-prepareBeanFactory-beanFactory"><a href="#4-prepareBeanFactory-beanFactory" class="headerlink" title="4.  prepareBeanFactory(beanFactory);"></a>4.  prepareBeanFactory(beanFactory);</h3><p>作用：准备beanFactory</p>
<h4 id="1-设置beanClassLoader，使用容器构造函数中获得的classLoader"><a href="#1-设置beanClassLoader，使用容器构造函数中获得的classLoader" class="headerlink" title="1. 设置beanClassLoader，使用容器构造函数中获得的classLoader."></a>1. 设置beanClassLoader，使用容器构造函数中获得的classLoader.</h4><h4 id="2-设置beanExpressionResolver为StandardBeanExpressionResolver"><a href="#2-设置beanExpressionResolver为StandardBeanExpressionResolver" class="headerlink" title="2. 设置beanExpressionResolver为StandardBeanExpressionResolver"></a>2. 设置beanExpressionResolver为StandardBeanExpressionResolver</h4><p>表达式使用SpelExpressionParser，即SPEL表达式解析器</p>
<h4 id="3-调用addBeanPostProcessor-添加bean后置处理器ApplicationContextAwareProcessor"><a href="#3-调用addBeanPostProcessor-添加bean后置处理器ApplicationContextAwareProcessor" class="headerlink" title="3. 调用addBeanPostProcessor(),添加bean后置处理器ApplicationContextAwareProcessor"></a>3. 调用addBeanPostProcessor(),添加bean后置处理器ApplicationContextAwareProcessor</h4><p>ApplicationContextAwareProcessor实现了BeanPostProcessor，作用是为实现了**Aware接口bean赋值。</p>
<p>**Aware接口有：EnvironmentAware，EmbeddedValueResolverAware，ResourceLoaderAware，ApplicationEventPublisherAware，MessageSourceAware，ApplicationContextAware</p>
<h4 id="4-调用ignoreDependencyInterface-添加忽略接口-忽略的接口类型有："><a href="#4-调用ignoreDependencyInterface-添加忽略接口-忽略的接口类型有：" class="headerlink" title="4. 调用ignoreDependencyInterface(),添加忽略接口,忽略的接口类型有："></a>4. 调用ignoreDependencyInterface(),添加忽略接口,忽略的接口类型有：</h4><h5 id="1-EnvironmentAware"><a href="#1-EnvironmentAware" class="headerlink" title="1. EnvironmentAware"></a>1. EnvironmentAware</h5><h5 id="2-EmbeddedValueResolverAware"><a href="#2-EmbeddedValueResolverAware" class="headerlink" title="2. EmbeddedValueResolverAware"></a>2. EmbeddedValueResolverAware</h5><h5 id="3-ResourceLoaderAware"><a href="#3-ResourceLoaderAware" class="headerlink" title="3. ResourceLoaderAware"></a>3. ResourceLoaderAware</h5><h5 id="4-ApplicationEventPublisherAware"><a href="#4-ApplicationEventPublisherAware" class="headerlink" title="4. ApplicationEventPublisherAware"></a>4. ApplicationEventPublisherAware</h5><h5 id="5-MessageSourceAware"><a href="#5-MessageSourceAware" class="headerlink" title="5. MessageSourceAware"></a>5. MessageSourceAware</h5><h5 id="6-ApplicationContextAware"><a href="#6-ApplicationContextAware" class="headerlink" title="6. ApplicationContextAware"></a>6. ApplicationContextAware</h5><h4 id="5-调用registerResolvableDependency-添加可解析的依赖"><a href="#5-调用registerResolvableDependency-添加可解析的依赖" class="headerlink" title="5. 调用registerResolvableDependency(), 添加可解析的依赖"></a>5. 调用registerResolvableDependency(), 添加可解析的依赖</h4><h5 id="1-BeanFactory"><a href="#1-BeanFactory" class="headerlink" title="1. BeanFactory"></a>1. BeanFactory</h5><h5 id="2-ResourceLoader"><a href="#2-ResourceLoader" class="headerlink" title="2. ResourceLoader"></a>2. ResourceLoader</h5><h5 id="3-ApplicationEventPublisher"><a href="#3-ApplicationEventPublisher" class="headerlink" title="3. ApplicationEventPublisher"></a>3. ApplicationEventPublisher</h5><h5 id="4-ApplicationContext"><a href="#4-ApplicationContext" class="headerlink" title="4. ApplicationContext"></a>4. ApplicationContext</h5><h4 id="6-调用addBeanPostProcessor-添加bean后置处理器ApplicationListenerDetector"><a href="#6-调用addBeanPostProcessor-添加bean后置处理器ApplicationListenerDetector" class="headerlink" title="6. 调用addBeanPostProcessor(),添加bean后置处理器ApplicationListenerDetector"></a>6. 调用addBeanPostProcessor(),添加bean后置处理器ApplicationListenerDetector</h4><h4 id="7-设置类加载期织入LTW（Load-Time-Weaving）"><a href="#7-设置类加载期织入LTW（Load-Time-Weaving）" class="headerlink" title="7. 设置类加载期织入LTW（Load Time Weaving）"></a>7. 设置类加载期织入LTW（Load Time Weaving）</h4><h4 id="8-调用registerSingleton-注册单例"><a href="#8-调用registerSingleton-注册单例" class="headerlink" title="8. 调用registerSingleton(),注册单例"></a>8. 调用registerSingleton(),注册单例</h4><p>key和value对应关系如下：</p>
<ol>
<li>environment    &gt;&gt;    ConfigurableEnvironment</li>
<li>systemProperties    &gt;&gt;    getEnvironment().getSystemProperties()</li>
<li>systemEnvironment    &gt;&gt;    getEnvironment().getSystemEnvironment()</li>
</ol>
<h3 id="5-postProcessBeanFactory-beanFactory"><a href="#5-postProcessBeanFactory-beanFactory" class="headerlink" title="5. postProcessBeanFactory(beanFactory);"></a>5. postProcessBeanFactory(beanFactory);</h3><p>作用：预处理BeanFactory，留给子类来实现</p>
<h3 id="6-invokeBeanFactoryPostProcessors-beanFactory"><a href="#6-invokeBeanFactoryPostProcessors-beanFactory" class="headerlink" title="6. invokeBeanFactoryPostProcessors(beanFactory);"></a>6. invokeBeanFactoryPostProcessors(beanFactory);</h3><p>作用：触发BeanFactroy后置处理器</p>
<p>流程如下：</p>
<h4 id="1-getBeanFactoryPostProcessors-，得到当前存在的BeanFactroy后置处理器"><a href="#1-getBeanFactoryPostProcessors-，得到当前存在的BeanFactroy后置处理器" class="headerlink" title="1.  getBeanFactoryPostProcessors()，得到当前存在的BeanFactroy后置处理器"></a>1.  getBeanFactoryPostProcessors()，得到当前存在的BeanFactroy后置处理器</h4><p>此时的来源是手动通过调用addBeanFactoryPostProcessor()添加的</p>
<h4 id="2-PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors-）"><a href="#2-PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors-）" class="headerlink" title="2.  PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(）"></a>2.  PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(）</h4><p>作用： 触发BeanFactroy后置处理器</p>
<h5 id="1-判断beanFacotry是否是BeanDefinitionRegistry的实例，满足条件的话-执行下面的逻辑："><a href="#1-判断beanFacotry是否是BeanDefinitionRegistry的实例，满足条件的话-执行下面的逻辑：" class="headerlink" title="1. 判断beanFacotry是否是BeanDefinitionRegistry的实例，满足条件的话,执行下面的逻辑："></a>1. 判断beanFacotry是否是BeanDefinitionRegistry的实例，满足条件的话,执行下面的逻辑：</h5><h6 id="1-遍历beanFactoryPostProcessors"><a href="#1-遍历beanFactoryPostProcessors" class="headerlink" title="1. 遍历beanFactoryPostProcessors"></a>1. 遍历beanFactoryPostProcessors</h6><ol>
<li><p>如果当前的后置处理器是BeanDefinitionRegistryPostProcessor的实例</p>
<ol>
<li>触发postProcessBeanDefinitionRegistry方法</li>
<li>添加到registryProcessors列表中</li>
</ol>
</li>
<li><p>否则的话，添加到regularPostProcessors列表中</p>
<h6 id="2-执行beanFatory中实现了BeanDefinitionRegistryPostProcessor类型"><a href="#2-执行beanFatory中实现了BeanDefinitionRegistryPostProcessor类型" class="headerlink" title="2. 执行beanFatory中实现了BeanDefinitionRegistryPostProcessor类型"></a>2. 执行beanFatory中实现了BeanDefinitionRegistryPostProcessor类型</h6></li>
<li><p>执行实现了PriorityOrdered接口的BeanFactory后置处理器</p>
<p> 默认只有一个：ConfigurationClassPostProcessor</p>
<ol>
<li>排序</li>
<li>触发BeanDefinitionRegistryPostProcessor.postProcessBeanDefinitionRegistry方法</li>
</ol>
</li>
<li><p>执行实现了Ordered接口的BeanFactory后置处理器</p>
<ol>
<li>排序</li>
<li>触发BeanDefinitionRegistryPostProcessor.postProcessBeanDefinitionRegistry方法<br>这一步会调用ConfigurationClassPostProcessor的方法通过ComponentScan注解加载bean的定义</li>
</ol>
</li>
<li><p>执行剩下的后置处理器</p>
<ol>
<li>排序</li>
<li>触发BeanDefinitionRegistryPostProcessor.postProcessBeanDefinitionRegistry方法</li>
<li>执行在容器中注册的beanFactoryPostProcessor的postProcessBeanFactory方法</li>
<li>执行手动注册的beanFactoryPostProcessor的postProcessBeanFactory方法</li>
</ol>
</li>
</ol>
<h5 id="2-如果beanFactory不是BeanDefinitionRegistry的实例，调用手动注册的beanFactoryPostProcessor的postProcessBeanFactory方法"><a href="#2-如果beanFactory不是BeanDefinitionRegistry的实例，调用手动注册的beanFactoryPostProcessor的postProcessBeanFactory方法" class="headerlink" title="2. 如果beanFactory不是BeanDefinitionRegistry的实例，调用手动注册的beanFactoryPostProcessor的postProcessBeanFactory方法"></a>2. 如果beanFactory不是BeanDefinitionRegistry的实例，调用手动注册的beanFactoryPostProcessor的postProcessBeanFactory方法</h5><h5 id="3-处理beanFactory中类型是BeanFactoryPostProcessor的-已经处理的跳过"><a href="#3-处理beanFactory中类型是BeanFactoryPostProcessor的-已经处理的跳过" class="headerlink" title="3.  处理beanFactory中类型是BeanFactoryPostProcessor的,已经处理的跳过"></a>3.  处理beanFactory中类型是BeanFactoryPostProcessor的,已经处理的跳过</h5><ol>
<li>处理实现了接口PriorityOrdered的<ol>
<li>排序</li>
<li>调用BeanFactoryPostProcessor.postProcessBeanFactory方法</li>
</ol>
</li>
<li>处理实现了接口Ordered的<ol>
<li>排序</li>
<li>调用BeanFactoryPostProcessor.postProcessBeanFactory方法</li>
</ol>
</li>
<li>处理剩下的,调用BeanFactoryPostProcessor.postProcessBeanFactory方法</li>
</ol>
<h5 id="4-beanFactory-clearMetadataCache"><a href="#4-beanFactory-clearMetadataCache" class="headerlink" title="4. beanFactory.clearMetadataCache()"></a>4. beanFactory.clearMetadataCache()</h5><h4 id="3-处理loadTimeWeaver"><a href="#3-处理loadTimeWeaver" class="headerlink" title="3.  处理loadTimeWeaver"></a>3.  处理loadTimeWeaver</h4><h3 id="7-registerBeanPostProcessors-beanFactory"><a href="#7-registerBeanPostProcessors-beanFactory" class="headerlink" title="7. registerBeanPostProcessors(beanFactory)"></a>7. registerBeanPostProcessors(beanFactory)</h3><blockquote>
<p>注册Bean后置处理器</p>
</blockquote>
<p>调用了 PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this)，执行流程如下：</p>
<h4 id="1-从容器中获取类型为BeanPostProcessor的bean名称列表"><a href="#1-从容器中获取类型为BeanPostProcessor的bean名称列表" class="headerlink" title="1. 从容器中获取类型为BeanPostProcessor的bean名称列表"></a>1. 从容器中获取类型为BeanPostProcessor的bean名称列表</h4><h4 id="2-向容器中添加一个BeanPostProcessorChecker类型的bean后置处理器"><a href="#2-向容器中添加一个BeanPostProcessorChecker类型的bean后置处理器" class="headerlink" title="2.  向容器中添加一个BeanPostProcessorChecker类型的bean后置处理器"></a>2.  向容器中添加一个BeanPostProcessorChecker类型的bean后置处理器</h4><h4 id="3-获取BeanPostProcessor实例，并且按照以下顺序调用beanFactory-addBeanPostProcessor添加到容器中"><a href="#3-获取BeanPostProcessor实例，并且按照以下顺序调用beanFactory-addBeanPostProcessor添加到容器中" class="headerlink" title="3. 获取BeanPostProcessor实例，并且按照以下顺序调用beanFactory.addBeanPostProcessor添加到容器中"></a>3. 获取BeanPostProcessor实例，并且按照以下顺序调用beanFactory.addBeanPostProcessor添加到容器中</h4><p>PriorityOrdered    》    Ordered    》    剩下的    》MergedBeanDefinitionPostProcessor类型的</p>
<h4 id="4-向容器中添加一个ApplicationListenerDetector类型的bean后置处理器"><a href="#4-向容器中添加一个ApplicationListenerDetector类型的bean后置处理器" class="headerlink" title="4. 向容器中添加一个ApplicationListenerDetector类型的bean后置处理器"></a>4. 向容器中添加一个ApplicationListenerDetector类型的bean后置处理器</h4><h3 id="8-initMessageSource"><a href="#8-initMessageSource" class="headerlink" title="8. initMessageSource();"></a>8. initMessageSource();</h3><h3 id="9-initApplicationEventMulticaster"><a href="#9-initApplicationEventMulticaster" class="headerlink" title="9.  initApplicationEventMulticaster();"></a>9.  initApplicationEventMulticaster();</h3><p>作用：初始化应用程序事件多播器</p>
<p>判断容器中是否包含名称为applicationEventMulticaster的bean，不存在的话实例化SimpleApplicationEventMulticaster注册到容器中（调用了beanFactory.registerSingleton方法）。</p>
<h3 id="10-onRefresh"><a href="#10-onRefresh" class="headerlink" title="10. onRefresh()"></a>10. onRefresh()</h3><p>作用：此方法留给子类来实现，初始化些特定的bean.</p>
<h3 id="11-registerListeners"><a href="#11-registerListeners" class="headerlink" title="11. registerListeners();"></a>11. registerListeners();</h3><p>作用： 将ApplicationListener类型的对象添加到应用程序事件多播器</p>
<h3 id="1-将手动注册（通过调用容器方法addApplicationListener）的ApplicationListener对象添加到应用程序事件多播器"><a href="#1-将手动注册（通过调用容器方法addApplicationListener）的ApplicationListener对象添加到应用程序事件多播器" class="headerlink" title="1. 将手动注册（通过调用容器方法addApplicationListener）的ApplicationListener对象添加到应用程序事件多播器"></a>1. 将手动注册（通过调用容器方法addApplicationListener）的ApplicationListener对象添加到应用程序事件多播器</h3><h3 id="2-将容器中ApplicationListener类型的bean添加到应用程序事件多播器"><a href="#2-将容器中ApplicationListener类型的bean添加到应用程序事件多播器" class="headerlink" title="2. 将容器中ApplicationListener类型的bean添加到应用程序事件多播器"></a>2. 将容器中ApplicationListener类型的bean添加到应用程序事件多播器</h3><h3 id="3-如果容器的earlyApplicationEvents字段不为空，即存在需要发布的应用程序事件，则调用应用程序事件多播器来广播事件。"><a href="#3-如果容器的earlyApplicationEvents字段不为空，即存在需要发布的应用程序事件，则调用应用程序事件多播器来广播事件。" class="headerlink" title="3. 如果容器的earlyApplicationEvents字段不为空，即存在需要发布的应用程序事件，则调用应用程序事件多播器来广播事件。"></a>3. 如果容器的earlyApplicationEvents字段不为空，即存在需要发布的应用程序事件，则调用应用程序事件多播器来广播事件。</h3><h3 id="12-finishBeanFactoryInitialization-beanFactory"><a href="#12-finishBeanFactoryInitialization-beanFactory" class="headerlink" title="12. finishBeanFactoryInitialization(beanFactory);"></a>12. finishBeanFactoryInitialization(beanFactory);</h3><p>作用：完成BeanFacotry初始化工作，实例化剩下的非延迟（Lazy注解）的单例作用域的bean.</p>
<h3 id="1-初始化BeanFactory的转换服务字段（ConversionService类型）"><a href="#1-初始化BeanFactory的转换服务字段（ConversionService类型）" class="headerlink" title="1. 初始化BeanFactory的转换服务字段（ConversionService类型）"></a>1. 初始化BeanFactory的转换服务字段（ConversionService类型）</h3><h3 id="2-判断容器是否有内嵌的值解析器，如果没有使用环境的解析器"><a href="#2-判断容器是否有内嵌的值解析器，如果没有使用环境的解析器" class="headerlink" title="2. 判断容器是否有内嵌的值解析器，如果没有使用环境的解析器"></a>2. 判断容器是否有内嵌的值解析器，如果没有使用环境的解析器</h3><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">   beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-实例化容器中LoadTimeWeaverAware类型的bean"><a href="#3-实例化容器中LoadTimeWeaverAware类型的bean" class="headerlink" title="3. 实例化容器中LoadTimeWeaverAware类型的bean"></a>3. 实例化容器中LoadTimeWeaverAware类型的bean</h3><h3 id="4-将BeanFactory的临时类加载器设置为null"><a href="#4-将BeanFactory的临时类加载器设置为null" class="headerlink" title="4. 将BeanFactory的临时类加载器设置为null"></a>4. 将BeanFactory的临时类加载器设置为null</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.setTempClassLoader(<span class="keyword">null</span>)</span><br></pre></td></tr></table></figure>

<h3 id="5-将BeanFactory的配置冻结"><a href="#5-将BeanFactory的配置冻结" class="headerlink" title="5. 将BeanFactory的配置冻结"></a>5. 将BeanFactory的配置冻结</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.freezeConfiguration();</span><br></pre></td></tr></table></figure>

<h3 id="6-实例化剩下的非延迟（Lazy注解）的单例作用域的bean"><a href="#6-实例化剩下的非延迟（Lazy注解）的单例作用域的bean" class="headerlink" title="6. 实例化剩下的非延迟（Lazy注解）的单例作用域的bean"></a>6. 实例化剩下的非延迟（Lazy注解）的单例作用域的bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.preInstantiateSingletons();</span><br></pre></td></tr></table></figure>

<h4 id="1-获取bean定义名称列表"><a href="#1-获取bean定义名称列表" class="headerlink" title="1. 获取bean定义名称列表"></a>1. 获取bean定义名称列表</h4><h4 id="2-遍历bean定义名称列表"><a href="#2-遍历bean定义名称列表" class="headerlink" title="2. 遍历bean定义名称列表"></a>2. 遍历bean定义名称列表</h4><h5 id="1-获取当前bean的定义，判断必须满足条件才执行方法；条件为：非抽象-and-单例的-and-不是延迟加载"><a href="#1-获取当前bean的定义，判断必须满足条件才执行方法；条件为：非抽象-and-单例的-and-不是延迟加载" class="headerlink" title="1. 获取当前bean的定义，判断必须满足条件才执行方法；条件为：非抽象 and 单例的 and 不是延迟加载"></a>1. 获取当前bean的定义，判断必须满足条件才执行方法；条件为：非抽象 and 单例的 and 不是延迟加载</h5><h6 id="1-如果是FactoryBean的话："><a href="#1-如果是FactoryBean的话：" class="headerlink" title="1. 如果是FactoryBean的话："></a>1. 如果是FactoryBean的话：</h6><p>​     如果是SmartFactoryBean类型的同时是饥饿初始（isEagerInit）设置时，调用getBean(beanName)；</p>
<h6 id="2-不是FactoryBean的话，调用getBean-beanName"><a href="#2-不是FactoryBean的话，调用getBean-beanName" class="headerlink" title="2. 不是FactoryBean的话，调用getBean(beanName)"></a>2. 不是FactoryBean的话，调用getBean(beanName)</h6><h4 id="3-遍历bean定义名称列表"><a href="#3-遍历bean定义名称列表" class="headerlink" title="3. 遍历bean定义名称列表"></a>3. 遍历bean定义名称列表</h4><p>获取bean对象，判断必须是SmartInitializingSingleton类型的，调用afterSingletonsInstantiated().</p>
<h3 id="13-finishRefresh"><a href="#13-finishRefresh" class="headerlink" title="13. finishRefresh()"></a>13. finishRefresh()</h3><p>作用：主逻辑最后一步，完成刷新，发布上下文已刷新事件</p>
<h4 id="1-清除资源缓存，clearResourceCaches"><a href="#1-清除资源缓存，clearResourceCaches" class="headerlink" title="1. 清除资源缓存，clearResourceCaches()"></a>1. 清除资源缓存，clearResourceCaches()</h4><h4 id="2-初始化生命周期处理器，initLifecycleProcessor"><a href="#2-初始化生命周期处理器，initLifecycleProcessor" class="headerlink" title="2. 初始化生命周期处理器，initLifecycleProcessor()"></a>2. 初始化生命周期处理器，initLifecycleProcessor()</h4><p>​    bean名称为lifecycleProcessor，如果容器中不存在，实例一个DefaultLifecycleProcessor类型的对象并注册到容器中。</p>
<h4 id="3-执行生命周期处理器刷新操作，getLifecycleProcessor-onRefresh"><a href="#3-执行生命周期处理器刷新操作，getLifecycleProcessor-onRefresh" class="headerlink" title="3. 执行生命周期处理器刷新操作，getLifecycleProcessor().onRefresh()"></a>3. 执行生命周期处理器刷新操作，getLifecycleProcessor().onRefresh()</h4><h4 id="4-发布上下文已刷新-ContextRefreshedEvent-事件"><a href="#4-发布上下文已刷新-ContextRefreshedEvent-事件" class="headerlink" title="4. 发布上下文已刷新(ContextRefreshedEvent)事件"></a>4. 发布上下文已刷新(ContextRefreshedEvent)事件</h4><h4 id="5-LiveBeansView-registerApplicationContext-this"><a href="#5-LiveBeansView-registerApplicationContext-this" class="headerlink" title="5. LiveBeansView.registerApplicationContext(this)"></a>5. LiveBeansView.registerApplicationContext(this)</h4><h3 id="14-destroyBeans"><a href="#14-destroyBeans" class="headerlink" title="14. destroyBeans();"></a>14. destroyBeans();</h3><p>作用：释放已经创建的单例bean</p>
<h3 id="15-cancelRefresh-ex"><a href="#15-cancelRefresh-ex" class="headerlink" title="15. cancelRefresh(ex);"></a>15. cancelRefresh(ex);</h3><p>作用：将active状态设置为false</p>
<h3 id="16-resetCommonCaches"><a href="#16-resetCommonCaches" class="headerlink" title="16. resetCommonCaches();"></a>16. resetCommonCaches();</h3><p>作用: 释放缓存</p>
<h4 id="1-ReflectionUtils-clearCache"><a href="#1-ReflectionUtils-clearCache" class="headerlink" title="1. ReflectionUtils.clearCache();"></a>1. ReflectionUtils.clearCache();</h4><h4 id="2-AnnotationUtils-clearCache"><a href="#2-AnnotationUtils-clearCache" class="headerlink" title="2. AnnotationUtils.clearCache();"></a>2. AnnotationUtils.clearCache();</h4><h4 id="3-ResolvableType-clearCache"><a href="#3-ResolvableType-clearCache" class="headerlink" title="3. ResolvableType.clearCache();"></a>3. ResolvableType.clearCache();</h4><h4 id="4-CachedIntrospectionResults-clearClassLoader-getClassLoader"><a href="#4-CachedIntrospectionResults-clearClassLoader-getClassLoader" class="headerlink" title="4. CachedIntrospectionResults.clearClassLoader(getClassLoader());"></a>4. CachedIntrospectionResults.clearClassLoader(getClassLoader());</h4><h1 id="3-AbstractBeanFactory-getBean方法执行过程"><a href="#3-AbstractBeanFactory-getBean方法执行过程" class="headerlink" title="3. AbstractBeanFactory.getBean方法执行过程"></a>3. AbstractBeanFactory.getBean方法执行过程</h1><p>此方法调用了doGetBean,只按照bean的名称获取对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//doGetBean方法签名</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">                          @Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-doGetBean执行过程如下："><a href="#1-doGetBean执行过程如下：" class="headerlink" title="1. doGetBean执行过程如下："></a>1. doGetBean执行过程如下：</h2><h3 id="1-获得bean名称"><a href="#1-获得bean名称" class="headerlink" title="1. 获得bean名称"></a>1. 获得bean名称</h3><h3 id="2-根据bean名称通过单例方法，获取共享实例"><a href="#2-根据bean名称通过单例方法，获取共享实例" class="headerlink" title="2. 根据bean名称通过单例方法，获取共享实例"></a>2. 根据bean名称通过单例方法，获取共享实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object sharedInstance = getSingleton(beanName)</span><br></pre></td></tr></table></figure>

<h3 id="3-如果共享实例有值并且args为null"><a href="#3-如果共享实例有值并且args为null" class="headerlink" title="3. 如果共享实例有值并且args为null"></a>3. 如果共享实例有值并且args为null</h3><h4 id="1-bean对象通过调用getObjectForBeanInstance得到"><a href="#1-bean对象通过调用getObjectForBeanInstance得到" class="headerlink" title="1. bean对象通过调用getObjectForBeanInstance得到"></a>1. bean对象通过调用getObjectForBeanInstance得到</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);</span><br></pre></td></tr></table></figure>

<h3 id="4-否则的话："><a href="#4-否则的话：" class="headerlink" title="4. 否则的话："></a>4. 否则的话：</h3><h4 id="1-如果目前处于创建保护状态，则跑出异常，解决循环依赖的问题"><a href="#1-如果目前处于创建保护状态，则跑出异常，解决循环依赖的问题" class="headerlink" title="1. 如果目前处于创建保护状态，则跑出异常，解决循环依赖的问题"></a>1. 如果目前处于创建保护状态，则跑出异常，解决循环依赖的问题</h4><h4 id="2-获取parentBeanFactory"><a href="#2-获取parentBeanFactory" class="headerlink" title="2. 获取parentBeanFactory"></a>2. 获取parentBeanFactory</h4><h4 id="3-如果parentBeanFactory有值并且包含bean定义的话："><a href="#3-如果parentBeanFactory有值并且包含bean定义的话：" class="headerlink" title="3. 如果parentBeanFactory有值并且包含bean定义的话："></a>3. 如果parentBeanFactory有值并且包含bean定义的话：</h4><h4 id="4-如果typeCheckOnly为false的话，标记下beanName为已创建，"><a href="#4-如果typeCheckOnly为false的话，标记下beanName为已创建，" class="headerlink" title="4. 如果typeCheckOnly为false的话，标记下beanName为已创建，"></a>4. 如果typeCheckOnly为false的话，标记下beanName为已创建，</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">markBeanAsCreated(beanName)</span><br></pre></td></tr></table></figure>

<h4 id="5-获取当前bean的定义"><a href="#5-获取当前bean的定义" class="headerlink" title="5. 获取当前bean的定义"></a>5. 获取当前bean的定义</h4><h4 id="6-检查下当前bean的定义（目前只做了一件事情，如果是抽象的话，抛出异常）"><a href="#6-检查下当前bean的定义（目前只做了一件事情，如果是抽象的话，抛出异常）" class="headerlink" title="6. 检查下当前bean的定义（目前只做了一件事情，如果是抽象的话，抛出异常）"></a>6. 检查下当前bean的定义（目前只做了一件事情，如果是抽象的话，抛出异常）</h4><h4 id="7-根据当前bean的定义获取到依赖（String-dependsOn-mbd-getDependsOn-）"><a href="#7-根据当前bean的定义获取到依赖（String-dependsOn-mbd-getDependsOn-）" class="headerlink" title="7. 根据当前bean的定义获取到依赖（String[] dependsOn = mbd.getDependsOn()）"></a>7. 根据当前bean的定义获取到依赖（String[] dependsOn = mbd.getDependsOn()）</h4><h4 id="8-循环依赖，实例化依赖的bean"><a href="#8-循环依赖，实例化依赖的bean" class="headerlink" title="8. 循环依赖，实例化依赖的bean"></a>8. 循环依赖，实例化依赖的bean</h4><h4 id="9-根据当前bean的定义判断是否是单例的："><a href="#9-根据当前bean的定义判断是否是单例的：" class="headerlink" title="9. 根据当前bean的定义判断是否是单例的："></a>9. 根据当前bean的定义判断是否是单例的：</h4><h5 id="1-调用createBean创建共享实例（sharedInstance）"><a href="#1-调用createBean创建共享实例（sharedInstance）" class="headerlink" title="1. 调用createBean创建共享实例（sharedInstance）"></a>1. 调用createBean创建共享实例（sharedInstance）</h5><h5 id="2-bean对象通过调用getObjectForBeanInstance得到"><a href="#2-bean对象通过调用getObjectForBeanInstance得到" class="headerlink" title="2. bean对象通过调用getObjectForBeanInstance得到"></a>2. bean对象通过调用getObjectForBeanInstance得到</h5><h4 id="10-是原型的（prototype）话："><a href="#10-是原型的（prototype）话：" class="headerlink" title="10. 是原型的（prototype）话："></a>10. 是原型的（prototype）话：</h4><h5 id="1-执行beforePrototypeCreation-beanName"><a href="#1-执行beforePrototypeCreation-beanName" class="headerlink" title="1. 执行beforePrototypeCreation(beanName)"></a>1. 执行beforePrototypeCreation(beanName)</h5><h5 id="2-通过调用createbean方法得到原型实例"><a href="#2-通过调用createbean方法得到原型实例" class="headerlink" title="2. 通过调用createbean方法得到原型实例"></a>2. 通过调用createbean方法得到原型实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prototypeInstance = createBean(beanName, mbd, args);</span><br></pre></td></tr></table></figure>

<h5 id="3-执行afterPrototypeCreation-beanName"><a href="#3-执行afterPrototypeCreation-beanName" class="headerlink" title="3. 执行afterPrototypeCreation(beanName);"></a>3. 执行afterPrototypeCreation(beanName);</h5><h5 id="4-bean对象通过调用getObjectForBeanInstance得到"><a href="#4-bean对象通过调用getObjectForBeanInstance得到" class="headerlink" title="4. bean对象通过调用getObjectForBeanInstance得到"></a>4. bean对象通过调用getObjectForBeanInstance得到</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br></pre></td></tr></table></figure>

<h4 id="11-否则的话："><a href="#11-否则的话：" class="headerlink" title="11. 否则的话："></a>11. 否则的话：</h4><h5 id="1-根据bean定义获取作用域范围名称-String-scopeName-mbd-getScope"><a href="#1-根据bean定义获取作用域范围名称-String-scopeName-mbd-getScope" class="headerlink" title="1. 根据bean定义获取作用域范围名称;String scopeName = mbd.getScope();"></a>1. 根据bean定义获取作用域范围名称;String scopeName = mbd.getScope();</h5><h5 id="2-根据作用域范围名称获取作用域范围接口"><a href="#2-根据作用域范围名称获取作用域范围接口" class="headerlink" title="2. 根据作用域范围名称获取作用域范围接口"></a>2. 根据作用域范围名称获取作用域范围接口</h5><h5 id="3-调用获取作用域范围接口得到实例"><a href="#3-调用获取作用域范围接口得到实例" class="headerlink" title="3. 调用获取作用域范围接口得到实例"></a>3. 调用获取作用域范围接口得到实例</h5><h5 id="4-bean对象通过调用getObjectForBeanInstance得到-1"><a href="#4-bean对象通过调用getObjectForBeanInstance得到-1" class="headerlink" title="4. bean对象通过调用getObjectForBeanInstance得到"></a>4. bean对象通过调用getObjectForBeanInstance得到</h5><h4 id="12-如果期望的类型有值并且bean不是期望的类型的实例的话："><a href="#12-如果期望的类型有值并且bean不是期望的类型的实例的话：" class="headerlink" title="12. 如果期望的类型有值并且bean不是期望的类型的实例的话："></a>12. 如果期望的类型有值并且bean不是期望的类型的实例的话：</h4><h5 id="1-调用类型转换将bean转换为期望的类型，并当做结果返回"><a href="#1-调用类型转换将bean转换为期望的类型，并当做结果返回" class="headerlink" title="1. 调用类型转换将bean转换为期望的类型，并当做结果返回"></a>1. 调用类型转换将bean转换为期望的类型，并当做结果返回</h5><h2 id="2-getObjectForBeanInstance方法"><a href="#2-getObjectForBeanInstance方法" class="headerlink" title="2. getObjectForBeanInstance方法"></a>2. getObjectForBeanInstance方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程如下：</p>
<h3 id="1-根据bean名称判断是否是工厂bean的引用-以-amp-开头-，是的话："><a href="#1-根据bean名称判断是否是工厂bean的引用-以-amp-开头-，是的话：" class="headerlink" title="1. 根据bean名称判断是否是工厂bean的引用(以&amp;开头)，是的话："></a>1. 根据bean名称判断是否是工厂bean的引用(以&amp;开头)，是的话：</h3><h4 id="1-如果bean是NullBean类型的实例，直接返回bean"><a href="#1-如果bean是NullBean类型的实例，直接返回bean" class="headerlink" title="1. 如果bean是NullBean类型的实例，直接返回bean"></a>1. 如果bean是NullBean类型的实例，直接返回bean</h4><h4 id="2-如果bean不是FactoryBean类型的实例，抛出异常"><a href="#2-如果bean不是FactoryBean类型的实例，抛出异常" class="headerlink" title="2. 如果bean不是FactoryBean类型的实例，抛出异常"></a>2. 如果bean不是FactoryBean类型的实例，抛出异常</h4><h3 id="2-如果bean不是FactoryBean类型的实例-或者，不是工厂bean的引用-以-amp-开头-那么直接返回bean"><a href="#2-如果bean不是FactoryBean类型的实例-或者，不是工厂bean的引用-以-amp-开头-那么直接返回bean" class="headerlink" title="2. 如果bean不是FactoryBean类型的实例,或者，不是工厂bean的引用(以&amp;开头),那么直接返回bean"></a>2. 如果bean不是FactoryBean类型的实例,或者，不是工厂bean的引用(以&amp;开头),那么直接返回bean</h3><h3 id="3-如果bean定义为空，从缓存之获取返回值。"><a href="#3-如果bean定义为空，从缓存之获取返回值。" class="headerlink" title="3. 如果bean定义为空，从缓存之获取返回值。"></a>3. 如果bean定义为空，从缓存之获取返回值。</h3><h3 id="4-如果返回值为空："><a href="#4-如果返回值为空：" class="headerlink" title="4. 如果返回值为空："></a>4. 如果返回值为空：</h3><h4 id="1-将bean转换为FactoryBean类型的对象"><a href="#1-将bean转换为FactoryBean类型的对象" class="headerlink" title="1. 将bean转换为FactoryBean类型的对象"></a>1. 将bean转换为FactoryBean类型的对象</h4><h4 id="2-调用getObjectFromFactoryBean获取返回结果（调用了FactoryBean的get方法）"><a href="#2-调用getObjectFromFactoryBean获取返回结果（调用了FactoryBean的get方法）" class="headerlink" title="2. 调用getObjectFromFactoryBean获取返回结果（调用了FactoryBean的get方法）"></a>2. 调用getObjectFromFactoryBean获取返回结果（调用了FactoryBean的get方法）</h4><h2 id="3-createBean方法"><a href="#3-createBean方法" class="headerlink" title="3. createBean方法"></a>3. createBean方法</h2><p>签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程：</p>
<h3 id="1-获取目标class类型"><a href="#1-获取目标class类型" class="headerlink" title="1. 获取目标class类型"></a>1. 获取目标class类型</h3><h3 id="2-调用resolveBeforeInstantiation方法获取bean-目标是给BeanPostProcessors一个机会返回目标实例的一个代理"><a href="#2-调用resolveBeforeInstantiation方法获取bean-目标是给BeanPostProcessors一个机会返回目标实例的一个代理" class="headerlink" title="2. 调用resolveBeforeInstantiation方法获取bean;目标是给BeanPostProcessors一个机会返回目标实例的一个代理"></a>2. 调用resolveBeforeInstantiation方法获取bean;目标是给BeanPostProcessors一个机会返回目标实例的一个代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br></pre></td></tr></table></figure>

<p>resolveBeforeInstantiation方法执行流程如下:</p>
<h4 id="1-判断是否有InstantiationAwareBeanPostProcessor类型的bean后置处理器，没有的话，退出"><a href="#1-判断是否有InstantiationAwareBeanPostProcessor类型的bean后置处理器，没有的话，退出" class="headerlink" title="1. 判断是否有InstantiationAwareBeanPostProcessor类型的bean后置处理器，没有的话，退出"></a>1. 判断是否有InstantiationAwareBeanPostProcessor类型的bean后置处理器，没有的话，退出</h4><h4 id="2-循环所有的BeanPostProcessor"><a href="#2-循环所有的BeanPostProcessor" class="headerlink" title="2. 循环所有的BeanPostProcessor"></a>2. 循环所有的BeanPostProcessor</h4><h5 id="1-如果当前类型是InstantiationAwareBeanPostProcessor的话，调用postProcessBeforeInstantiation方法，如果有返回结果退出循环"><a href="#1-如果当前类型是InstantiationAwareBeanPostProcessor的话，调用postProcessBeforeInstantiation方法，如果有返回结果退出循环" class="headerlink" title="1. 如果当前类型是InstantiationAwareBeanPostProcessor的话，调用postProcessBeforeInstantiation方法，如果有返回结果退出循环"></a>1. 如果当前类型是InstantiationAwareBeanPostProcessor的话，调用postProcessBeforeInstantiation方法，如果有返回结果退出循环</h5><h4 id="3-如果有返回结果的话，循环所有的BeanPostProcessor，调用postProcessAfterInitialization；"><a href="#3-如果有返回结果的话，循环所有的BeanPostProcessor，调用postProcessAfterInitialization；" class="headerlink" title="3. 如果有返回结果的话，循环所有的BeanPostProcessor，调用postProcessAfterInitialization；"></a>3. 如果有返回结果的话，循环所有的BeanPostProcessor，调用postProcessAfterInitialization；</h4><h3 id="3-如果bean不为空，直接返回结果"><a href="#3-如果bean不为空，直接返回结果" class="headerlink" title="3. 如果bean不为空，直接返回结果"></a>3. 如果bean不为空，直接返回结果</h3><h3 id="4-调用doCreateBean得到bean"><a href="#4-调用doCreateBean得到bean" class="headerlink" title="4. 调用doCreateBean得到bean"></a>4. 调用doCreateBean得到bean</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br></pre></td></tr></table></figure>

<p>分析下doCreateBean的执行过程</p>
<p>首先，签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>doCreateBean方法执行流程如下：</p>
<h4 id="1-判断是否是单例的，如果是的话，从缓存中获取实例包装对象（instanceWrapper），并且删除缓存中的值"><a href="#1-判断是否是单例的，如果是的话，从缓存中获取实例包装对象（instanceWrapper），并且删除缓存中的值" class="headerlink" title="1. 判断是否是单例的，如果是的话，从缓存中获取实例包装对象（instanceWrapper），并且删除缓存中的值"></a>1. 判断是否是单例的，如果是的话，从缓存中获取实例包装对象（instanceWrapper），并且删除缓存中的值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">	instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-如果实例包装对象为null，调用createBeanInstance创建，注意此时已经实例化了"><a href="#2-如果实例包装对象为null，调用createBeanInstance创建，注意此时已经实例化了" class="headerlink" title="2. 如果实例包装对象为null，调用createBeanInstance创建，注意此时已经实例化了"></a>2. 如果实例包装对象为null，调用createBeanInstance创建，注意此时已经实例化了</h4><h4 id="3-循环BeanPostProcessor-执行类型为MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition方法"><a href="#3-循环BeanPostProcessor-执行类型为MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition方法" class="headerlink" title="3. 循环BeanPostProcessor,执行类型为MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition方法"></a>3. 循环BeanPostProcessor,执行类型为MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition方法</h4><h4 id="4-获取热点单例（earlySingletonExposure）标记，当为单例，开启循环依赖，当前bean处在创建中时标记为true"><a href="#4-获取热点单例（earlySingletonExposure）标记，当为单例，开启循环依赖，当前bean处在创建中时标记为true" class="headerlink" title="4. 获取热点单例（earlySingletonExposure）标记，当为单例，开启循环依赖，当前bean处在创建中时标记为true."></a>4. 获取热点单例（earlySingletonExposure）标记，当为单例，开启循环依赖，当前bean处在创建中时标记为true.</h4><p>earlySingletonExposure的作用是解决<strong>循环依赖</strong>的问题</p>
<h4 id="5-如果热点单例为true，添加到单例工厂中"><a href="#5-如果热点单例为true，添加到单例工厂中" class="headerlink" title="5. 如果热点单例为true，添加到单例工厂中"></a>5. 如果热点单例为true，添加到单例工厂中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">        <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">        <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-调用populateBean"><a href="#6-调用populateBean" class="headerlink" title="6. 调用populateBean"></a>6. 调用populateBean</h4><p>循环BeanPostProcessor,执行类型为InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation方法</p>
<h4 id="7-调用initializeBean"><a href="#7-调用initializeBean" class="headerlink" title="7. 调用initializeBean"></a>7. 调用initializeBean</h4><h5 id="1-调用invokeAwareMethods，为实现了BeanNameAware，BeanClassLoaderAware，BeanFactoryAware赋值属性"><a href="#1-调用invokeAwareMethods，为实现了BeanNameAware，BeanClassLoaderAware，BeanFactoryAware赋值属性" class="headerlink" title="1. 调用invokeAwareMethods，为实现了BeanNameAware，BeanClassLoaderAware，BeanFactoryAware赋值属性"></a>1. 调用invokeAwareMethods，为实现了BeanNameAware，BeanClassLoaderAware，BeanFactoryAware赋值属性</h5><h5 id="2-循环BeanPostProcessor，执行postProcessBeforeInitialization方法"><a href="#2-循环BeanPostProcessor，执行postProcessBeforeInitialization方法" class="headerlink" title="2. 循环BeanPostProcessor，执行postProcessBeforeInitialization方法"></a>2. 循环BeanPostProcessor，执行postProcessBeforeInitialization方法</h5><h5 id="3-调用invokeInitMethods完成初始化"><a href="#3-调用invokeInitMethods完成初始化" class="headerlink" title="3. 调用invokeInitMethods完成初始化"></a>3. 调用invokeInitMethods完成初始化</h5><p>如果bean实现了InitializingBean接口，执行InitializingBean.afterPropertiesSet方法</p>
<p>如果bean定义中表明了使用初始化方法（@bean(initMethod)）,调用对应的方法</p>
<h5 id="4-循环BeanPostProcessor，执行postProcessAfterInitialization方法"><a href="#4-循环BeanPostProcessor，执行postProcessAfterInitialization方法" class="headerlink" title="4. 循环BeanPostProcessor，执行postProcessAfterInitialization方法"></a>4. 循环BeanPostProcessor，执行postProcessAfterInitialization方法</h5><p>BeanFactoryPostProcessor接口</p>
<p>签名为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Modify the application context's internal bean factory after its standard</span></span><br><span class="line"><span class="comment">	 * initialization. All bean definitions will have been loaded, but no beans</span></span><br><span class="line"><span class="comment">	 * will have been instantiated yet. This allows for overriding or adding</span></span><br><span class="line"><span class="comment">	 * properties even to eager-initializing beans.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanFactory the bean factory used by the application context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在生命周期的InvokeBeanFactoryPostProcessor阶段执行</p>
<p>子接口：BeanDefinitionRegistryPostProcessor</p>
<p>签名为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Extension to the standard &#123;<span class="doctag">@link</span> BeanFactoryPostProcessor&#125; SPI, allowing for</span></span><br><span class="line"><span class="comment"> * the registration of further bean definitions &lt;i&gt;before&lt;/i&gt; regular</span></span><br><span class="line"><span class="comment"> * BeanFactoryPostProcessor detection kicks in. In particular,</span></span><br><span class="line"><span class="comment"> * BeanDefinitionRegistryPostProcessor may register further bean definitions</span></span><br><span class="line"><span class="comment"> * which in turn define BeanFactoryPostProcessor instances.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.annotation.ConfigurationClassPostProcessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Modify the application context's internal bean definition registry after its</span></span><br><span class="line"><span class="comment">	 * standard initialization. All regular bean definitions will have been loaded,</span></span><br><span class="line"><span class="comment">	 * but no beans will have been instantiated yet. This allows for adding further</span></span><br><span class="line"><span class="comment">	 * bean definitions before the next post-processing phase kicks in.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> registry the bean definition registry used by the application context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConfigurationClassPostProcessor类</p>
<p>签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>,</span></span><br><span class="line"><span class="class">		<span class="title">PriorityOrdered</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化时机：</p>
<p>BeanDefinitionRegistryPostProcessor的Bean定义在AnnotationConfigApplicationContenxt构造函数初始化reader的时候添加到BeanFactory中</p>
<p>实现了ResourceLoaderAware，BeanClassLoaderAware和EnvironmentAware此三个接口对应的资源ResourceLoader，BeanClassLoader和Environment是在PrepareBeanFactory阶段添加到容器中</p>
<p>作用：加载bean定义；</p>
<p>由于此类实现了BeanDefinitionRegistryPostProcessor所以我们关注两个重写方法：</p>
<p>postProcessBeanDefinitionRegistry，postProcessBeanFactory</p>
<p>先分析下postProcessBeanDefinitionRegistry</p>
<p>执行过程：</p>
<ol>
<li><p>打标记防止重复执行</p>
</li>
<li><p>循环容器中所有的bean定义名称，从中选出候选配置类</p>
<p>判断是否是候选配置类，分两种一个是完整版的(full),一个是精简版的(lite);full是指标注了@Configuration的类；精简版是指标注了任意一个以下的注解：@Component，@ComponentScan，@Import，@ImportResource或者该类中存在标注了@Bean的方法。</p>
</li>
<li><p>如果候选配置列表为空，直接退出</p>
</li>
<li><p>候选配置列表中的成员进行排序</p>
</li>
<li><p>创建配置类解析器（ConfigurationClassParser）</p>
</li>
<li><p>调用配置类解析器的parse解析候选配置类列表</p>
</li>
<li><p>调用配置类解析器的validate</p>
</li>
</ol>
<p>​        </p>
<p>未解之谜：</p>
<p>循环依赖的解决</p>
<p>ConfigurableEnvironment, getSystemProperties,getSystemEnvironment</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liu-rui.github.io/2019/07/01/spring源码分析/" data-id="ck0evarrf000htwnnbkmzhmrj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring-源码-分析/">spring 源码 分析</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-源码研究经验" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/30/源码研究经验/" class="article-date">
  <time datetime="2019-06-30T03:27:04.000Z" itemprop="datePublished">2019-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/30/源码研究经验/">源码研究经验</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对源码的研究无论对平时业务的开发还是个人技术水平的成长都会有很大的帮助，技术人员不能光停留在使用的层次，还要懂得背后的原理。</p>
<p>源码的研究需要有耐心，当然也有些方法。本文总结了源码研究的一些方法；</p>
<ol>
<li>第一步，源码fork到自己的仓库中 fork到自己仓库有几个好处：</li>
</ol>
<ul>
<li>可以随时修改代码，添加注释</li>
<li>当官方发生变化的时候，可以与自己仓库对比，发现版本的变化</li>
</ul>
<ol start="2">
<li><p>源码下载到本地，必须编译通过   </p>
</li>
<li><p>在源码中创建业务代码或功能代码，这样可以使用当前的源码调试</p>
</li>
<li><p>研究源码最好的方式就是一步一步的调试</p>
</li>
<li><p>源码会有多个版本，只研究当前正在使用的版本；</p>
</li>
<li><p>研究源码要有目的性</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liu-rui.github.io/2019/06/30/源码研究经验/" data-id="ck0evarqt000btwnnd96yyt9t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码-经验/">源码 经验</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-sharding-jdbc源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/28/sharding-jdbc源码分析/" class="article-date">
  <time datetime="2019-06-28T09:45:19.000Z" itemprop="datePublished">2019-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/28/sharding-jdbc源码分析/">sharding-jdbc源码分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.汇总</p>
<table>
<thead>
<tr>
<th>源码</th>
<th><a href="https://github.com/apache/incubator-shardingsphere" target="_blank" rel="noopener">https://github.com/apache/incubator-shardingsphere</a></th>
</tr>
</thead>
<tbody><tr>
<td>官网</td>
<td><a href="https://shardingsphere.apache.org/" target="_blank" rel="noopener">https://shardingsphere.apache.org/</a></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liu-rui.github.io/2019/06/28/sharding-jdbc源码分析/" data-id="ck0evarqc0005twnni6as5425" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mybatis-plus源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/27/mybatis-plus源码分析/" class="article-date">
  <time datetime="2019-06-27T03:25:29.000Z" itemprop="datePublished">2019-06-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/27/mybatis-plus源码分析/">mybatis-plus源码分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>信息</p>
<table>
<thead>
<tr>
<th>源码</th>
<th><a href="https://github.com/baomidou/mybatis-plus" target="_blank" rel="noopener">https://github.com/baomidou/mybatis-plus</a></th>
</tr>
</thead>
<tbody><tr>
<td>官方实例</td>
<td><a href="https://github.com/baomidou/mybatis-plus-samples" target="_blank" rel="noopener">https://github.com/baomidou/mybatis-plus-samples</a></td>
</tr>
<tr>
<td>mybatis官网</td>
<td><a href="https://blog.mybatis.org/" target="_blank" rel="noopener">https://blog.mybatis.org/</a></td>
</tr>
<tr>
<td></td>
<td><a href="https://github.com/mybatis" target="_blank" rel="noopener">https://github.com/mybatis</a></td>
</tr>
<tr>
<td>mybatis源码</td>
<td><a href="https://github.com/mybatis/mybatis-3" target="_blank" rel="noopener">https://github.com/mybatis/mybatis-3</a></td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="2">
<li></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liu-rui.github.io/2019/06/27/mybatis-plus源码分析/" data-id="ck0evarq60001twnnakw4uh4n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-spring-boot-admin的使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/27/spring-boot-admin的使用/" class="article-date">
  <time datetime="2019-06-27T01:45:48.000Z" itemprop="datePublished">2019-06-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/27/spring-boot-admin的使用/">spring-boot-admin的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>参考</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/forezp/p/10242004.html</span><br></pre></td></tr></table></figure>
</li>
<li><p>简介</p>
</li>
</ol>
<ul>
<li>共需要建立两个项目：admin-server-demo和admin-client-demo.</li>
</ul>
<ol start="3">
<li>配置admin-server-demo</li>
</ol>
<ul>
<li><p>idea-新建项目-spring initializr</p>
</li>
<li><p>选择 web-spring web starter</p>
</li>
<li><p>选择 ops-spring boot Actuator和spring boot admin(server)</p>
</li>
<li><p>application项目上增加注解@EnableAdminServer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableAdminServer</span><br><span class="line">public class AdminServerDemoApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(AdminServerDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>application.properties配置如下</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.port=8081</span><br><span class="line">spring.application.name=admin-server</span><br></pre></td></tr></table></figure>

<ul>
<li>启动项目配置，admin-server-demo配置完成</li>
</ul>
<ol start="4">
<li>配置admin-client-demo</li>
</ol>
<ul>
<li><p>idea-新建项目-spring initializr</p>
</li>
<li><p>选择 web-spring web starter</p>
</li>
<li><p>选择 ops-spring boot Actuator和spring boot admin(client)</p>
</li>
<li><p>添加action</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@RestController</span><br><span class="line">public class AdminClientDemoApplication &#123;</span><br><span class="line">    @GetMapping(path = &quot;/a&quot;)</span><br><span class="line">    public String get() &#123;</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(AdminClientDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>application.properties配置如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.port=8082</span><br><span class="line">spring.application.name=admin-client</span><br><span class="line">spring.boot.admin.client.url=http://localhost:8081</span><br><span class="line">management.endpoints.web.exposure.include=*</span><br><span class="line">management.endpoint.health.show-details=always</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liu-rui.github.io/2019/06/27/spring-boot-admin的使用/" data-id="ck0evarqo0008twnnc75bwmkf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring-boot-admin/">spring boot admin</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-skywalking部署" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/27/skywalking部署/" class="article-date">
  <time datetime="2019-06-27T01:44:48.000Z" itemprop="datePublished">2019-06-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/27/skywalking部署/">skywalking部署</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>安装版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6.1.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.apache.org/dyn/closer.cgi/skywalking/6.1.0/apache-skywalking-apm-6.1.0.zip</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务器端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/startup.cmd</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:D:\software\apache-skywalking-apm-6.1.0\apache-skywalking-apm-bin\agent\skywalking-agent.jar  -jar demo29-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
</li>
<li><p>UI</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080   admin/admin</span><br></pre></td></tr></table></figure>

</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liu-rui.github.io/2019/06/27/skywalking部署/" data-id="ck0evarqn0007twnnjzosuf07" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/skywalking/">skywalking</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/flutter/">flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/skywalking/">skywalking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-boot/">spring boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-boot-admin/">spring boot admin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-源码-分析/">spring 源码 分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码-经验/">源码 经验</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/flutter/" style="font-size: 10px;">flutter</a> <a href="/tags/skywalking/" style="font-size: 10px;">skywalking</a> <a href="/tags/spring-boot/" style="font-size: 10px;">spring boot</a> <a href="/tags/spring-boot-admin/" style="font-size: 10px;">spring boot admin</a> <a href="/tags/spring-源码-分析/" style="font-size: 10px;">spring 源码 分析</a> <a href="/tags/源码-经验/" style="font-size: 10px;">源码 经验</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/06/consul/">consul</a>
          </li>
        
          <li>
            <a href="/2019/09/06/微服务/">微服务</a>
          </li>
        
          <li>
            <a href="/2019/07/29/idea使用/">idea使用</a>
          </li>
        
          <li>
            <a href="/2019/07/17/flutter环境搭建/">flutter环境搭建</a>
          </li>
        
          <li>
            <a href="/2019/07/01/spring源码分析/">spring源码分析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 liu rui<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>